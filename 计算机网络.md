* [什么是 HTTP](#什么是-http)
* [什么是 HTTPS](#什么是-https)
* [HTTP 特点](#http-特点)
* [针对 HTTP 无状态的一些解决策略](#针对-http-无状态的一些解决策略)
* [二者区别](#二者区别)
* [客户端使用 HTTPS 方式与 Web 端进行通信时的步骤](#客户端使用-https-方式与-web-端进行通信时的步骤)
* [HTTPS 的缺点](#https-的缺点)
* [HTTP 返回码（状态码）](#http-返回码状态码)
* [IP 地址和 MAC 地址的作用](#ip-地址和-mac-地址的作用)
* [OSI 七层模型和 TCP/IP 四层模型](#osi-七层模型和-tcpip-四层模型)
* [三次握手](#三次握手)
* [三次握手的原因](#三次握手的原因)
* [四次挥手的原因](#四次挥手的原因)
* [TIME_WAIT](#time_wait)
* [TCP 可靠传输是如何保证的](#tcp-可靠传输是如何保证的)
* [socket API](#socket-api)
* [介绍一下 UDP 中的connect 函数](#介绍一下-udp-中的connect-函数)
* [阻塞、非阻塞 & 同步、异步](#阻塞-非阻塞-同步-异步)
* [HTTP 协议会话结束标志如何截断](#http-协议会话结束标志如何截断)
* [TCP 模型及状态转移](#tcp-模型及状态转移)

# 什么是 HTTP

超文本传输协议，是一个基于请求与响应，无状态的应用层协议，通常基于 TCP/IP 传输数据，互联网上应用最广泛的一种网络协议，所有的 www 文件都必须遵守这个标准，设计 HTTP 的初衷是为了提供一种发布和接收 html 页面的方法

# 什么是 HTTPS

《图解 HTTP》这本书中说到 HTTPS 是披着 SSL 外壳的 HTTP，HTTPS 是一种通过计算机网络进行安全通信的传输协议，经由 HTTP 进行通信，利用 SSL 建立安全信道，加密数据包，HTTPS 使用的主要目的是为了提供网站对服务器的身份认证，同时保护交换传输数据的隐私与完整性

# HTTP 特点

- 无状态：HTTP 协议对客户端没有状态存储，对事物也没有记忆能力，比如当我们访问一个网站的时候需要反复进行登录操作，
- 无连接：HTTP 1.1 之前，由于无状态码特点，每次请求都需要通过 TCP 三次握手四次挥手，和服务器重新建立连接，比如：某个客户端短时间内取请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，这需要耗费不必要的时间和流量
- 基于请求和相应：基本的特性，由客户端发起请求，服务器响应
- 简单快速、灵活
- 通信使用明文传输，请求和相应不会对通信方进行确认，无法保证数据的完整性

# 针对 HTTP 无状态的一些解决策略

- 通过 cookie 和 session 技术
- HTTP 1.1 持久连接的方法，只要任意一段没有明确要断开连接的话，则保持 TCP 连接状态，在请求首部字段中的 connection：keep:-alive 表示使用了持久连接

HTTPS 特点

- 基于 HTTP 协议，通过 SSL 提供加密处理数据，验证对方身份及数据完整性保护
- 内容加密：采用混合加密技术，中间者无法查看名文内容
- 验证身份：通过证书认证客户端访问的是自己的服务器
- 保护数据的完整性：防止传输的内容被中间人冒充或篡改

# 二者区别

- HTTPS 协议需要到 CA 申请证书，
- HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议
- HTTP 和 HTTPS 使用的是完全不同的连接方式，端口号也不一样，前者 80 后者 443
- HTTP 的连接很简单，是无状态的，HTTPS 则是由 SSL + HTTP 构建的可进行加密传输，身份认证的网络协议，比 HTTP 协议安全

# 客户端使用 HTTPS 方式与 Web 端进行通信时的步骤

- 客户端使用 HTTPS 的 URL 访问 Web 服务器，需要与 Web 服务器建立 SSL 连接
- Web 服务器收到客户端请求后，会将网站的证书信息传输一份给客户端
- 客户端的浏览器与 Web 服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级
- 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密并传送给网站
- Web 服务器利用自己的私钥解密出会话密钥
- Web 服务器利用会话密钥加密与客户端之间的通信

# HTTPS 的缺点

- 握手阶段耗时，
- 连接缓存没有 HTTP 高效，会增加数据开销和功耗，甚至已经有的安全措施也会收到影响
- SSL 证书昂贵，

# HTTP 返回码（状态码）

# IP 地址和 MAC 地址的作用

# OSI 七层模型和 TCP/IP 四层模型

# 三次握手

假设 A 为客户端 B 为服务端

- 首先服务端 B 处于 listen （监听）状态，等待客户端 A 的连接请求
- 客户端 A 向服务端 B 发送连接请求报文，同步 SYN = 1，确认 ACK = 1，此时选择一个初始的序号 x （用于对字节流进行编号），第一次连接建立
- 服务端 B 收到连接请求报文，如果同意该建立连接，则服务端 B 向客户端 A 发送一个连接确认报文，同步 SYN = 1，确认 ACK = 1，确认号为 x + 1，同时也选择一个初始的序号 y，第二次连接建立
- 客户端 A 收到服务端 B 的连接请求报文后，还要向服务端 B 发出确认，确认号为 y + 1，序号为 x + 1
- 服务端 B 收到 客户端 A 的确认后，第三次连接建立，TCP 连接建立

# 三次握手的原因

**第三次握手是为了防止失效的连接请求到达服务器，让服务器错误的打开连接**

客户端发送的连接请求如果在网络中滞留，那么就会隔着很长一段时间才能收到服务器发回的连接确认，客户端等待一个超时重传时间后，就会重新请求连接，但是这个滞留的请求连接还是会到达服务器，如果不进行第三次握手，那么服务器就会打开两个连接，如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的确认，不进行第三次握手。

四次挥手

- 客户端 A 主动发送连接释放报文，终止 FIN = 1
- 服务端 B 收到之后发出确认，此时 TCP 属于半关闭状态，服务端 B 能向客户端 A 发送数据，但是客户端 A 不能向服务端 B 发送信息
- 当服务端 B 不再需要连接时，发送连接释放报文，终止 FIN = 1
- 客户端 A 收到发出确认，进入 TIME_WAIT 状态，等待 2MSL（最大报文存活时间） 后释放连接
- 服务端 B 收到客户端 A 的确认后释放连接

# 四次挥手的原因

客户端发送了终止 FIN 连接释放报文后，服务器收到了这个报文，就进入 CLOSED_WAIT 状态，这个状态是为了让服务器发送未发送完的数据，传送完毕之后，服务器发送终止 FIN 连接释放报文

# TIME_WAIT

客户端收到服务端的终止 FIN 连接释放报文后进入此状态，此时并不是直接进入 CLOSED_WAIT 状态，还需要等待 2MSL 后，这样做的理由：

- 确保最后一个由服务端发送而来的确认报文能够顺利到达，如果没有收到客户端发送来的连接释放报文，那么就会重新发送连接释放请求报文
- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个连接不会出现旧的连接请求

# TCP 可靠传输是如何保证的

TCP 使用超时重传来实现可靠传输，如果一个已发送的报文段在超时时间内没有收到确认，那么就会重传这个报文段，

浏览器输入 baidu.com 会发生什么

TCP 拥塞控制，以及达到什么情况的时候开始减慢增长速度

TCP/IP 数据链路层的交互过程

传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文

socket 的开发，具体网络层的操作该怎么做（网络编程的基本步骤）

请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？

TCP 握手为什么不是两次或者四次，什么原因

TCP、UDP 各自的使用场景

Time_Wait、Closed_Wait 状态

GET 和 POST 的区别

# socket API

```cpp
int socket(int domain, int type, int protocol);//创建文件描述符（套接字）
//domain	协议版本号（ipv4 or ipv6)
//type		协议类型（UDP or TCP）
int bind(int socket, const struct sockaddr* address, size_t address_len);//绑定端口号
//socket		socket() 的返回值
struct sockaddr_in local;
local.sin_family = AF_INET;
local.sin_port = htons(atoi(argv[2]));
local.sin_addr.s_addr = inet_addr(argv[1]);
//address		local
int listen(int socket, int backlog);//监听
//socket		socket
//backlog		_BACKLOG_
int accept(int sockfd, const struct sockaddr* address, size_t address_len);//接收请求
int connect(int sockfd, const struct sockaddr* address, size_t address_len);//连接
//sockfd		socket
//address		local
```

# 介绍一下 UDP 中的connect 函数



# 阻塞、非阻塞 & 同步、异步

# HTTP 协议会话结束标志如何截断

# TCP 模型及状态转移