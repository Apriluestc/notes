* [strlen 的常规写法和递归写法](#strlen-的常规写法和递归写法)
  * [常规写法](#常规写法)
  * [递归写法](#递归写法)
* [strcpy 和 strncpy 的代码和区别及安全性](#strcpy-和-strncpy-的代码和区别及安全性)
  * [strcpy](#strcpy)
  	* [为什么要返回 char* 类型](#为什么要返回-char-类型)
  	* [strcpy 和 memcpy 的区别](#strcpy-和-memcpy-的区别)
  * [strncpy](#strncpy)
* [快速排序的实现 & 复杂度](#快速排序的实现-复杂度)
  * [什么是快速排序](#什么是快速排序)
  * [快速排序算法的改进方面](#快速排序算法的改进方面)
* [设计一个内存池(一)](#设计一个内存池一)
  * [首先我们来说什么是内存池](#首先我们来说什么是内存池)
  * [内存池设计](#内存池设计)
* [内存池设计（二）](#内存池设计二)

# strlen 的常规写法和递归写法

## 常规写法

```cpp
int my_strlen(const char* str){
    int _count = 0;
    while(*str != '\0'){
        _count++;
        str++;
    }
    return _count;
}
```

## 递归写法

```cpp
int my_strlen(const char* str){
    int _count = 0;
    if(*str == '\0')
        return 0;
    else
        return 1 + my_strlen(str + 1)
}
```

# strcpy 和 strncpy 的代码和区别及安全性

## strcpy

```cpp
char* my_strcpy(char* dst, const char* src){
    assert(dst != nullptr);
    assert(src != nullptr);
    char* tmp = dst;
    while(* tmp++ = *src++)
        ;
    return tmp;
}
```

### 为什么要返回 char* 类型

为了实现链式连接，返回内容为指向目标内存的地址指针，这样可以在需要字符指针的函数中使用 strcpy，

源地址和目标地址出现内存重叠时，如何保证复制的正确性

使用检测内存重叠机制 memcpy

```cpp
char* my_memcpy(char* dst, const char* src, int size){
    assert(dst != nullptr);
    assert(src != nullptr);
    if(dst == nullptr || src == nullptr)
        return nullptr;
    char* tmp = dst;
    //从高地址开始拷贝
    if(dst > src && dst < src + size - 1){
        dst = dst + size - 1;
        src = src + size - 1;
    }
    while(size--){
        *dst-- = *src--;
    }
    else
        while(size--){
            *dst++ = *src++;
        }
    return tmp;
}
```

### strcpy 和 memcpy 的区别

- strcpy 提供了字符串的复制，但是仅仅用于字符串的复制，不仅复制字符串内容而且还会将字符串结束标志复制
- memcpy 对于拷贝的内容没有限制，其第三个参数用来决定复制的长度

## strncpy

**首先我会这么实现**

```cpp
char* my_strncpy(char* dst, const char* src, int size){
    assert(dst != nullptr);
    assert(src != nullptr);
    char* tmp = dst;
    while(len--){
        *dst++ = *src++;
    }
    return tmp;
}
```

**如果是这样写的话，会出现一些问题**

- 拷贝完的字符串并没有结束标志
- 如果目的字符串的长度比 size 小该如何是好
- 如果源字符串的长度比 size 小或者大又该如何是好
- 什么时候会出现内存重叠（出现内存重叠应该从高地址往低地址拷贝）
- 其实 strncpy 的目的就是向目的字符串中写入 size 个字符；

**针对以上有几种解决方案**

- 如果 size < strlen(src) 那么拷贝至目的串中的字符串将不会以 '\0' 结尾，所以要在拷贝完成后追加字符串结尾标志
- 如果 size > strlen(dst) 那么拷贝至目的串中的字符串就会覆盖掉原来字符串的结尾标志，这样的话应该考虑到内存重叠，从高地址向低地址拷贝，即从后向前复制
- 如果内存重叠和源字符串的长度不够 size，这又改如何解决，这样做：内存重叠我们可以从后向前拷贝，源字符串长度小于 size 则在目的串的后面补 NULL，然后再追加 '\0'

# 快速排序的实现 & 复杂度

## 什么是快速排序

首先选定一个值，然后扫描待排序序列，把小于该值的记录和大于该值的记录分成两个单独的序列，然后分别对这两个序列进行上述操作，这就是排序。`其一般步骤为：`

- 从数列中挑选一个元素，我们将其称为 “基准值”
- 重新排序此序列，把比基准小的元素放在基准的前面，大于基准的元素放在基准的后边，这样的操作称为分区（partition）
- 递归地把小于基准的子序列和大于基准的子序列进行上述操作

```cpp
void quicksort(int array[], int left, int right){
    int key = array[left];
    int i = left, j = right;
    if(left >= right)
        return ;
    //一趟快速排序
    while(i < j){
        while(i < j && array[j] >= key)
            j--;
        array[i] = array[j];	//如果基准后边的值小于基准，则交换
        while(i < j && array[i] <= key)
            i++;
        array[j] = array[i];	//如果基准前面的值大于基准，则交换
    }
    array[i] = key;	//基准值归位
    //分别对左右两个子序列排序
    quicksort(array, left, i - 1);
    quicksort(array, i + 1, right);
}
```

**算法分析**

- 上述算法在选取基准值的时候，选的是最左边的元素，这样的话在已经有序的序列中，每次划分得到最坏的情况，`解决办法就是在选取基准值的时候随机选取，增加其随机性`

- 随机化算法 `partition`

- ```cpp
  int random(int array[], int left, int right){
      int i = rand() % (right - left) + left;
      swap(array[i], array[left]);
      return array[left];
  }
  int partition(int array[], int left, int right){
      int i = left, j = right;
      int key = random(array, left, right);
      while(i < j)
      {
          while(i < j && array[j] >= key)
              j--;
          array[i] = array[j];
          while(i < j && array[i] <= key)
              i++;
          array[i] = array[j];
      }
      array[i] = key;
      return i;
  }
  void quicksort(int array[], int left, int right){
      if(left >= right)
          return ;
      int p = partition(array, left, right);
      quicksort(array, left, p - 1);
      quicksort(array, p + 1, right);
  }
  
  int partition(T[] nums, int l, int h) {
      int i = l, j = h + 1;
      T v = nums[l];
      while (true) {
          while (less(nums[++i], v) && i != h) ;
          while (less(v, nums[--j]) && j != l) ;
          if (i >= j)
              break;
          swap(nums, i, j);
      }
      swap(nums, l, j);
      return j;
  }
  
  int partition(int nums[], int left, int right){
      int i = left, int j = right;
      int key = nums[left];
      while(i < j){
          while(nums[i] <= key && i != right)
              i++;
          while(nums[j] >= key && j != left)
              j--;
          swap(nums[i], nums[j]);
      }
      swap(nums[left], nums[j]);
      return j;
  }
  ```

  

## 快速排序算法的改进方面

- 基准值的选区（推荐随机化）
- 根据产生的子分区不断调整算法
- 划分分区的方式

# 设计一个内存池(一)

## 首先我们来说什么是内存池

通常我们使用 new 和 amlloc 来分配内存的话，由于申请的大小不确定，所以当频繁使用时会造成内存碎片和效率的降低，为了克服这一问题，我们提出了内存池，内存池是一种内存的分配方式，其优点是有效地减少内存碎片化，分配内存更快速，减少内存泄漏

## 内存池设计

- 初始化，在创建内存池的时候为内存池分配了一块很大的内存，便于以后使用
- 分配内存，当需要内存的时候就去内存池里面分配内存
- 回收内存，当从内存池分配而来的内存使用完毕后，就需要将这块内存释放掉

设计的主要问题就是：`如何重复利用释放回来的内存，可以达到较高的效率`

```cpp
//用链表来实现内存池，每一个结点都挂有一块内存
template<class T>
class ObjectPool
{
   struct BlockNode         //每一个结点类型
   {
       void* _memory;        //指向一块已经分配的内存
       BlockNode * _next;    //指向下一个结点
       size_t _objNum;       //记录这块内存中对象的个数
       BlockNode(size_t objNum)
           :_objNum(objNum)
           , _next(NULL)
       {
           _memory = malloc(_objNum*_itemSize);
       }
       ~BlockNode()
       {
           free(_memory);
           _memory = NULL;
           _next = NULL;
           _objNum = 0;
       }
   };
protected:
    size_t _countIn;      //当前结点的在用的计数
    BlockNode* _frist;    //指向链表的头
    BlockNode* _last;     //指向链表的尾
    size_t _maxNum;        //记录内存块最大的容量
    static size_t _itemSize;   //单个对象的大小
    T* _lastDelete;        //指向最新释放的那个对象的空间
public:
	ObjectPool(size_t initNum = 32, size_t maxNum = 100000)  //默认最开始内存块有32个对象，一个内存块最大有maxNum个对象
        :_countIn(0)
        , _maxNum(maxNum)
        , _lastDelete(NULL)
	{
    	_frist = _last =new BlockNode(initNum);   //先开辟一个结点，这个结点里面的内存块能够存放initNum个对象
    }
	~ObjectPool()
   	{
        Destory();
    }
    T* New()                   //分配内存
    {
        if (_lastDelete)         //先到释放已经用完并且换回来的内存中去找
        {
            T* object = _lastDelete;
            _lastDelete = *((T**)_lastDelete);  //将_lastDelete转换成T**，*引用再取出来T*，也就是取出前T*类型大小的单元
            return new(object) T();        //把这块内存用从定位new初始化一下
        }
        //判断还有没有已经分配的内存且还未使用,如果没有内存的话就要再分配内存
        if (_countIn >= _last->_objNum)     //大于等于表示没有了，这时候就要分配内存了
        {
            size_t size =2*_countIn;
            if (size > _maxNum)            //块的最大大小不能超过maxNum，如果没超过就以二倍增长
                size = _maxNum;
            _last->_next = new BlockNode(size);
            _last = _last->_next;
            _countIn = 0;
        }
        //还有已经分配好的未被使用的内存
        T* object =(T*)（(char*)_last->_memory + _countIn*_itemSize）;
        _countIn++;
        return new(object) T();        //将这块空间用重定位new初始化一下
    }
    void Destory()
    {
        BlockNode *cur = _frist;
        while (cur)
        {
        	BlockNode* del = cur;
            cur = cur->_next;
            delete del;            //会自动调用~BlockNode()
        }
        _frist = _last = NULL;
    }
    void Delete(T* object)          //释放内存
    {
        if (object)
        {
            object->~T();       
            *((T**)object) = _lastDelete;      //将_lastDelete里面保存的地址存到tmp指向空间的前T*大小的空间里面
            _lastDelete = object;
        }
    }
protected:
	static size_t GetItemSize()
    {
        if (sizeof(T)>sizeof(T*))
        {
            return sizeof(T);
        }
        else
        {
            return sizeof(T*);
        }
    }
};
template<typename T>
size_t ObjectPool<T>::_itemSize =ObjectPool<T>::GetItemSize();          //类外初始化静态变量_itemSize
```

# 内存池设计（二）

[!Documents]()

# 字符串的反转

## C++ string 实现逆序

```cpp
std::string reverse(std::string str){
    std::string s(str.rbegin(), str.rend());
    return s;
} 
```

## 一般字符串反转算法

```cpp
void reverse(char* left, char* right){
    assert(left != nullptr);
    assert(right != nullptr);
    while(left < right){
        *left ^= *right;
        *right ^= *left;
        *left ^= *right;
        left++;
        right--;
    }
}
```

多态概念及实现方式