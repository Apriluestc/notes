* [基本概念](#基本概念)
* [虚拟内存](#虚拟内存)
* [分页系统地址映射](#分页系统地址映射)
* [页面置换算法](#页面置换算法)
	* [最佳](#最佳)
	* [最近最久未使用](#最近最久未使用)
	* [最近未使用](#最近未使用)
	* [先进先出](#先进先出)
	* [第二次机会算法](#第二次机会算法)
	* [时钟](#时钟)
* [分段](#分段)
* [段页式](#段页式)
* [分页与分段的比较](#分页与分段的比较)

# 基本概念

- 虚拟内存：用辅助存储器作为内存的补充，从而得到更大的逻辑地址让程序获得更大多的可用内存
- 内存管理单元 MMU：集成在 CPU 上，分解逻辑地址，逻辑地址到物理地址的转换，，查找更新快表，进程切换清空快表，设置和检查页表中各个特征位
- 虚拟地址空间（地址空间）：分配给某个进程（程序）的虚拟地址范围

# 虚拟内存

一般情况下用磁盘作为内存的补充，虚拟内存允许程序执行时只将部分程序放入内存，因此程序可以比物理内存大，虚拟内存大小受限于计算机寻址能力和辅助存储容量大小，不受限于内存容量。其目的是为了得到更大的逻辑内存，从而让程序获得更多的可用内存

为了更好的管理内存，操作系统将内存抽象为地址空间，每个程序都有自己的地址空间，这个地址空间被分为多个块，每块称为一页，这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有的也都在物理内存中，当程序引用不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败前的命令

# 分页系统地址映射

MMU 管理着地址空间和物理内存的转换，其中的页表存储着页（程序地址空间）和页框（物理内存空间）的映射表

一个虚拟地址分为两个部分：页面号和偏移量

# 页面置换算法

在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页面调入内存中，此时如果内存已没有闲置空间，系统必须从内存中调出一个页面到磁盘兑换区中来腾出空间

页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓冲。在缓存系统中，缓存的大小有限，当有新的缓存达到时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据

页面置换算法主要是使得页面置换频率降到最低（缺页率最低）

## 最佳

所选择的被置换出的页面将是最长时间不在被访问的，通常可以保证最低的缺页率

这仅仅是一种理论上的算法，因为无法知道一个页面多长时间不被访问

举个栗子：一个系统为某个进程分配了三个物理快，并由如下页面引用序列

70120304230320201702

开始运行时，先将 7、0、1 三个页面装入内存，当进程要访问页面 2 时，会将页面 7 置换出，因为页面 7 再次被访问的时间最长

## 最近最久未使用

虽然无法知道将来要是用页面的情况，但是可以知道过去使用页面的情况，LRU 将最近最久未使用的页面置换出

为了实现 LRU，需要在内存中维护一个所有页面的链表，当一个页面被访问时，将这个页面移到表头，这样就能保证链表表尾的页面是最近最久未使用的

每次访问页面都需要更新链表

## 最近未使用

每个页面都有两种状态位，R 与 M，当页面被访问时设置页面的 R = 1，当页面被修改时设置 M = 1，其中 R 会被定时清零

当发生缺页中断时，NRU 算法随机地从编号最小的非空类中挑选一个页面将它置换出

NRU 算法优先置换出已经被修改的脏页面（R = 0，M = 1），而不是被频繁的使用干净页面（R = 1，M = 0）

## 先进先出

选择换出的页面是最先进入页面，该算法会将那些经常被访问的页面换出，从而使得缺页率升高

## 第二次机会算法

FIFO 算法可能会把经常被访问的页面置换出去，为了避免这一问题：做出如下修改

当页面被访问（读或者写）时将该页面的 R 设为 1，需要替换的时候，检查最老页面的 R 位，如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉，如果是 1，就将 R 位先清零，并把该页面放到链表的尾端，修改它的装入时间使它就像刚入的一样，然后继续从链表头部开始搜索

## 时钟

第二次机会算法需要在链表中移动页面，降低了效率时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面

# 分段

虚拟内存采用的是分页技术，也就是将地址空间划分为固定大小的页，每一页在于内存进行映射

# 段页式

程序地地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间分成大小相同的页，这样既有分段系统的共享和保护，又拥有分页系统的虚拟内存功能

# 分页与分段的比较

- 对程序员的透明性：分页透明，但是分段需要程序员显示划分每个段
- 地址空间的维度：分页是一维 的，分段是二维的
- 大小是否可以改变：页的大小不可变，段的大小可以动态改变
- 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间，分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护